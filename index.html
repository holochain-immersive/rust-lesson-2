<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="Description" content="Put your description here." />
  <base href="/" />

  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background-color: #ededed;
      --r-main-font-size: 24px;
      --r-heading-margin: 20px 0 12px 0;
    }

    section {
      top: 10px !important;
    }

    .hljs-keyword {
      color: hsl(242deg 75% 71%) !important;
    }

    .slides {
      width: 75% !important;
    }

    .container {
      top: 0 !important;
      display: flex !important;
      flex-direction: row !important;
    }

    .column {
      flex: 1;
    }

    section {
      text-align: left;
    }

    .popover {
      position: absolute;
      background-color: #4d4d4d;
      padding: 1rem 2rem;
      box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
      border-radius: 10px;
      width: auto;
      transform: translate(35px, -15px);
    }

    .popover:after {
      content: "";
      position: absolute;
      top: 6px;
      left: -10px;
      border-style: solid;
      border-width: 25px 25px 0;
      border-color: #4d4d4d transparent;
      display: block;
      width: 0;
      z-index: 1;
      transform: translate(-50%, 50%) rotate(90deg);
    }

    .reveal pre code {
      max-height: 800px !important;
    }
  </style>
  <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" />
  <link rel="stylesheet" href="/node_modules/reveal.js/dist/theme/black.css" />
  <link rel="stylesheet" href="/node_modules/reveal.js/plugin/highlight/monokai.css" />
  <title>Lesson 2</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h1>Non-Primitive Types</h1>
      </section>

      <section>
        <h3>Structs</h3>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// Structs with fields
struct Person { // Name is TitleCase
  name: String,
  age: u32
}
<span class="fragment fade-in">
// Instantiating
let person = Person {
  name: String::from("Alice"),
  age: 33
};</span>
<span class="fragment fade-in">
// Accessing a field
let name: String = person.name;</span>

<span class="fragment fade-in">// Destructuring from the properties of a struct to local variables
let Person { name, age } = person;</span></span>

<span class="fragment fade-in-then-semi-out"><span class="fragment">// Tuple Structs</span>
<span class="fragment">struct Color(u32, u32, u32);</span>
<span class="fragment">
// Instantiating</span>
<span class="fragment fade-in">let banner_color = Color(25, 50, 255);</span>
<span class="fragment fade-in">
// Accessing a member, just like a tuple</span>
<span class="fragment fade-in">let banner_green_intensity: u32 = banner_color.1;</span>

<span class="fragment fade-in">// Destructuring
let (red_intensity, green_intensity, blue_intensity) = banner_color;</span></span>

<span class="fragment fade-in-then-semi-out"><span class="fragment">// Unit Structs</span>
<span class="fragment">struct Utc;</span>
<span class="fragment fade-in-then-semi-out">let utc = Utc;</span></span></code></pre><span class="fragment"></span>
      </section>

      <section>
        <h3>Initializing structs with fields</h3>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// Defining the struct
struct Person {
  name: String,
  age: u32
}</span>

<span class="fragment fade-in-then-semi-out">// Instantiating a struct
let alice = Person {
  name: String::from("Alice"),
  age: 48
};</span>

<span class="fragment fade-in-then-semi-out">// Shorthand field assignment
let name = String::from("Bob");
let bob = Person {
  name, // Variable name and field name need to match
  age: 33
};</span>

<span class="fragment fade-in-then-semi-out">// Shorthand doesn't work with references
fn create_homonymous_from_name(name: &String) -> Person {
  <span class="fragment strike">Person {
    name, // Err, name is a reference
    age: 33
  }</span>
}</span>

<span class="fragment fade-in-then-semi-out">// Shorthand struct update syntax 
let alice = Person {
  name: String::from("Alice"),
  age: 55
};
let bob = Person {
  name: String::from("Bob"), 
  ..alice // Both instances must be of the same struct type
          // Shorthand must be at the end
};
<span class="fragment fade-in-then-semi-out">let bob = Person {
  name: String::from("Bob"), 
  <span class="fragment strike">..alice </span> // Err, "alice" was consumed in the previous shorthad 
};</span></span>

<span class="fragment fade-in-then-semi-out">// Shorthand doesn't work with references
fn create_homonymous_from_person(person: &Person) -> Person {
  <span class="fragment strike">Person {
    age: 33,
    ..person // Err, person is a reference
  }</span>
}</span>

            </code></pre>
      </section>

      <section>
        <h3>Structs: ownership and mutability</h3>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// Accessing fields
let alice = Person {
  name: String::from("Alice"),
  age: 33
};
<span class="fragment fade-in-then-semi-out">println!("Alice's name is {}", alice.name); // prints "Alice's name is Alice"</span>
<span class="fragment fade-in-then-semi-out">let age: u32 = alice.age;
let age: u32 = alice.age; // Ok, u32 is unconsumable</span>
<span class="fragment fade-in">let name: String = alice.name;</span>
<span class="fragment fade-in-then-semi-out"><span class="fragment strike">let name: String = alice.name;</span> // Err, "alice" was partially consumed in the previous line</span>
<span class="fragment fade-in-then-semi-out"><span class="fragment strike">println!("Alice's name is {}", alice.name);</span> // Err, "alice" was partially consumed in the previous line</span></span>

<span class="fragment fade-in-then-semi-out">// Consumable by default, unlike tuples and arrays
struct Color(u32, u32, u32);

let blue_a = Color(0, 0, 255);
let blue_b = blue_a;
<span class="fragment strike">let blue_c = blue_a;</span> // Err, "blue_a" was consumed in the previous line</span>

<span class="fragment fade-in-then-semi-out">// Mutability cascades
let alice = Person {
  name: String::from("Alice"),
  age: 33
};
<span class="fragment strike">alice.age = 34;</span> // Err, "alice" is immutable</span>

<span class="fragment fade-in-then-semi-out">// Mutability cascades
let mut alice = Person {
  name: String::from("Alice"),
  age: 33
};
alice.age = 34; // Ok
<span class="fragment fade-in">alice.age = 35; // Ok</span>
<span class="fragment fade-in">alice.name = String::from("Alice"); // Ok</span></span>

<span class="fragment fade-in-then-semi-out">// Mutability cascades
let color = Color(0, 0, 255);
<span class="fragment strike">color.0 = 100;</span> // Err, "color" is immutable</span></span>
<span class="fragment fade-in">let mut color = Color(0, 0, 255);
color.0 = 100; // Ok</span>
</code></pre>
      </section>

      <section>
        <h3>Implementation blocks: instance methods</h3>

        <div class="container">

          <div class="column">
            <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">struct Person {
  name: String,
  age: u32
}

<span class="fragment fade-in-then-semi-out">impl Person {
  <span class="fragment fade-in">// "self" must be the first parameter
  // Refers to the struct instance
  fn is_underage(&self) -> bool {
    self.age < 18
  }</span>
}

<span class="fragment fade-in">let alice = Person {
  name: String::from("Alice"),
  age: 33
};

// "alice" is "self" in this function call
let is_alice_underage: bool = alice.is_underage();</span></span>

<span class="fragment fade-in-then-semi-out">impl Person {
  // We need a mutable reference of a Person to call "change_name"
  fn change_name(&mut self, new_name: String) -> () {
    self.name = new_name;
  }
}

<span class="fragment fade-in-then-semi-out">let alice = Person {
  name: String::from("Alice"),
  age: 33
};
<span class="fragment strike">alice.change_name(String::from("Bob"));</span> // Err, "alice" was not declared as mutable</span>
<span class="fragment fade-in-then-semi-out">let mut alice = Person {
  name: String::from("Alice"),
  age: 33
};
alice.change_name(String::from("Bob")); // Ok</span></span>
</code></pre>
          </div>

          <div class="column">
            <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">impl Person {
  // We need full ownership of a Person to call "older_person"
  fn older_person(self, other_person: Person) -> Person {
    if self.age >= other_person.age {
      self
    } else {
      other_person
    }
  }
}

<span class="fragment fade-in-then-semi-out">let alice = Person {
  name: String::from("Alice"),
  age: 33
};
let bob = Person {
  name: String::from("Bob"),
  age: 34
};
let older_person = alice.older_person(bob);
<span class="fragment fade-in-then-semi-out"><span class="fragment strike">let name = alice.name;</span> // Err, "alice" was consumed when calling "older_person"</span>
<span class="fragment fade-in-then-semi-out"><span class="fragment strike">let name = bob.name;</span> // Err, "bob" was consumed when calling "older_person"</span>
</span></span> <!-- TODO: what to say about .into()? -->
</code></pre>

          </div>
        </div>
      </section>

      <section>
        <h3>Implementation blocks: static methods</h3>

        <li class="fragment fade-in-then-semi-out">
          There is no default constructor <br>
          <ul>
            <li class="fragment fade-in-then-semi-out">Define your own with static functions</li>
          </ul>
        </li>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">struct Person {
  name: String,
  age: u32
}

impl Person {
  <span class="fragment fade-in">// There is no "self" parameter
  // Does not require an existing person
  fn new(age: u32, name: String) -> Self { // "Self" refers to Person, the type we are implementing a block for
    Person {
      name,
      age
    }
  }</span>
}
<span class="fragment fade-in">
let alice = Person::new(33, String::from("Alice"));</span> <!-- TODO: what to say about from? -->
</span></code></pre>

      </section>

      <section>
        <h3>The String Struct</h3>

        <li class="fragment fade-in-then-semi-out">Not the same as a string literal (&str)</li>
        <li class="fragment fade-in-then-semi-out">String *is* a struct, so it behaves like one</li>
        <li class="fragment fade-in-then-semi-out">Dynamic allocation</li>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">let string_a = String::from("hello world!");
<span class="fragment fade-in-then-semi-out">let string_b = string_a;
<span class="fragment strike">let string_c = string_a;</span> // Err, "string_a" was consumed in the previous line</span></span>

<span class="fragment fade-in-then-semi-out">let mut string_a = String::from("hello");
string_a.push_str(" world!"); // ".push_str(&mut self)" needs a mutable reference to the String</span>

<span class="fragment fade-in-then-semi-out">// format!() is similar to println!(), but creates a String instead of printing
let string_a = String::from("world");
let string_b: String = format!("hello {}!", string_a);
<span class="fragment fade-in-then-semi-out">let string_c: String = format!("bye {}!", string_a); // Ok, format doesn't consume</span></span>
  

<span class="fragment fade-in-then-semi-out">// Does not support indexing
let s = String::from("hello world!");
<span class="fragment strike">let first_char = s[0];</span> // Err</span>  
</code></pre>
      </section>

      <section>
        <h3>Enums</h3>

        <li class="fragment fade-in-then-semi-out">Type that holds only variant from a fixed set</li>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// Defining an enum
enum ShapeType {
  Rectangle,
  Square,
  Triangle
}
<span class="fragment fade-in-then-semi-out">// Initializing an enum
let shape_type = ShapeType::Rectangle;

<span class="fragment fade-in-then-semi-out">// Matching
match shape_type {
  ShapeType::Rectangle => {
    println!("shape_type is a rectangle");
  },
  ShapeType::Triangle => {
    println!("shape_type is a triangle");
  },
  ShapeType::Square => {
    println!("shape_type is a square");
  },
}</span></span>

<span class="fragment fade-in-then-semi-out">let shape_type = ShapeType::Rectangle;
// Destructuring with "if let"
if let ShapeType::Rectangle = shape_type {
  println!("shape_type is a rectangle");
}</span>
</span>
</code></pre>
      </section>

      <section>
        <h3>Enums with payload (I)</h3>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// Imagine we define these types
enum ShapeType {
  Rectangle,
  Triangle,
  Square
}

<span class="fragment fade-in-then-semi-out">struct Rectangle {
  shape_type: ShapeType,
  width: f32,
  height: f32,
}
struct Triangle {
  shape_type: ShapeType,
  base: f32,
  height: f32
}
struct Square {
  shape_type: ShapeType,
  size: f32,
}

<span class="fragment fade-in-then-semi-out">// This style of joining types gives problems when writing functions for all types
fn area(shape: ?) -> f32 { ... }</span></span></span>
</code></pre>

      </section>

      <section>
        <h3>Enums with payload (II)</h3>

        <pre><code class="rust" data-noescape>// Instead, each enum variant can have its own payload
enum Shape {
  Rectangle {
    width: f32,
    height: f32,
  },
  Triangle {
    base: f32,
    height: f32
    },
  Square {
    size: f32
  }
}


<span class="fragment fade-in-then-semi-out">fn area(shape: Shape) -> f32 {
  match shape {
    // Destructuring of the enum payload
    Shape::Rectangle { width, height } => width * height, 
    Shape::Triangle { base, height } => width * height / 2,
    Shape::Square { size } => size * size,
  }
}</span>
</code></pre>

      </section>

      <section>
        <h3>Enums with payload (III)</h3>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// Every variant can have a different payload style
enum GeometricObjects {
  Point,         // Unit variant
  Line(u32, String),     // Tuple-like variant
  Rectangle {    // Struct-like variant
    width: f32,
    height: f32,
  },
}</span>
</code></pre>

      </section>

      <section>
        <h3>Matching (I)</h3>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// Matching doesn't consume
let shape = Shape::Rectangle;
match shape {
  Shape::Rectangle => {
    println!("shape is a rectangle");
  },
  Shape::Triangle => {
    println!("shape is a triangle");
  },
  Shape::Square => {
    println!("shape is a square");
  },
}
match shape { // Ok
  Shape::Rectangle => {
    println!("shape is a rectangle");
  },
  Shape::Triangle => {
    println!("shape is a triangle");
  },
  Shape::Square => {
    println!("shape is a square");
  },
}</span>

<span class="fragment fade-in-then-semi-out">let shape = Shape::Rectangle;
// Can have a return value
let is_rectangle = match shape {
  Shape::Rectangle => true,
  Shape::Triangle => false,
  Shape::Square => false,
}; // Notice the ';'</span>
<span class="fragment fade-in-then-semi-out">// But all match arms must return the same type
let is_rectangle = match shape {
  Shape::Rectangle => true,
  <span class="fragment strike">Shape::Triangle => String::from("No"), </span> // Err, arms don't return the same type
  Shape::Square => false,
};</span>

<span class="fragment fade-in-then-semi-out">let shape = Shape::Rectangle;
// Variants can be ommitted
let is_rectangle = match shape {
  Shape::Rectangle => true,
  _ => false, // '_' means "any other variant"
}; </span>
</code></pre>
      </section>

      <section>
        <h3>Matching (II)</h3>
        <li class="fragment fade-in-then-semi-out">One of the most powerful features of Rust</li>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// Matching over a boolean
let sample_boolean = true;
match sample_boolean {
  true => println!("sample_boolean is true"),
  false => println!("sample_boolean is false"),
}</span>

<span class="fragment fade-in-then-semi-out">// Matching over numbers
let sample_integer = 5;
match sample_integer {
  0 => println!("sample_integer is 0"),
  1..3 => println!("sample_integer is greater or equal than 1 and less than 3"),
  _ => println!("sample_integer is greater or equal than 3")
}</span>

<span class="fragment fade-in-then-semi-out">// Matching over characters
let sample_char = 'A';
match sample_char {
  'a'..='z' => println!("sample_char is lowercase"),
  'A'..='Z' => println!("sample_char is uppercase"),
  _ => println!("sample_char is not a letter")
}</span>
</code></pre>
      </section>

      <section>
        <h3>Matching (III)</h3>

        <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// '|' as or operator
let sample_integer_a = 5;
match sample_integer_a {
  0 | 1 | 2 => println!("sample_integer_a is less than 3"),
  _ => println!("sample_integer_a is greater or equal than 3")
}</span>

<span class="fragment fade-in-then-semi-out">// Using "if" to match
let sample_integer_a = 1;
let sample_integer_b = 5;
match sample_integer_a {
  0..=3 if sample_integer_b < 3 => println!("both sample_integer_a and sample_integer_b are less than 3"),
  _ => println!("some number is greater or equal to 3")
}</span>

<span class="fragment fade-in-then-semi-out">// If we have these types
enum Shape {
  Rectangle {
    width: f32,
    height: f32,
  },
  Triangle {
    base: f32,
    height: f32
    },
  Square {
    size: f32
  }
}

struct Image {
  image_src: String
}

enum SVGObject {
  Shape(Shape),
  Image(Image)
}

let svg_object = SVGObject::Shape(Shape::Square { size: 3.0 });
  
<span class="fragment fade-in-then-semi-out">// We can match like this
match svg_object {
  // Double destructuring
  SVGObject::Shape(Shape::Square { size }) => println!("svg_object is a square"),
  SVGObject::Image(Image { image_src }) => println!("svg_object is an image with image_src: {}", image_src),
  _ => {}
}</span></span>
</code></pre>

      </section>
    </div>
  </div>

  <script type="module">
    import Reveal from "reveal.js";
    import Markdown from "reveal.js/plugin/markdown/markdown.esm.js";
    import RevealHighlight from "reveal.js/plugin/highlight/highlight.esm.js";
    import RevealNotes from "reveal.js/plugin/notes/notes.esm.js";
    import RevealNestedFragments from "reveal.js-nested-fragments";

    let deck = new Reveal({
      transition: "none",
      plugins: [
        Markdown,
        RevealHighlight,
        RevealNotes,
        RevealNestedFragments,
      ],
    });
    deck.initialize();
  </script>
</body>

</html>