<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name="Description" content="Put your description here."><base href="/"><style>body,html{margin:0;padding:0;font-family:sans-serif;background-color:#ededed;--r-main-font-size:24px;--r-heading-margin:20px 0 12px 0}.slides{width:75%!important}.container{top:0!important;display:flex!important;flex-direction:row!important}.column{flex:1}section{text-align:left}.popover{position:absolute;background-color:#4d4d4d;padding:1rem 2rem;box-shadow:0 2px 5px 0 rgba(0,0,0,.26);border-radius:10px;width:auto;transform:translate(35px,-15px)}.popover:after{content:"";position:absolute;top:6px;left:-10px;border-style:solid;border-width:25px 25px 0;border-color:#4d4d4d transparent;display:block;width:0;z-index:1;transform:translate(-50%,50%) rotate(90deg)}.reveal pre code{max-height:800px!important}</style><link rel="stylesheet" href="rust-lesson-2/bce6cb85.css"><link rel="stylesheet" href="rust-lesson-2/5265d60d.css"><link rel="stylesheet" href="rust-lesson-2/86125abe.css"><title>Lesson 2/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="reveal"&gt; &lt;div class="slides"&gt; &lt;section&gt; &lt;h1&gt;Non-Primitive Types&lt;/h1&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Structs&lt;/h3&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;// Structs with fields struct Person { // Name is TitleCase name: String, age: u32 } &lt;span class="fragment fade-in"&gt;let person = Person { name: String::from("Alice"), age: 33 };&lt;/span&gt; &lt;span class="fragment fade-in"&gt;// Accessing a field let name: String = person.name;&lt;/span&gt;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Deestructuring let person = Person { name: String::from("Alice"), age: 33 }; let Person { name, age } = person;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Tuple Structs struct Color(u32, u32, u32); &lt;span class="fragment fade-in-then-semi-out"&gt;let blue = Color(0, 0, 255);&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Accessing a member, just like a tuple let red_component: u32 = blue.0;&lt;/span&gt; &lt;span class="fragment fade-in"&gt;let blue = Color(0, 0, 255); let (r, g, b) = blue;&lt;/span&gt;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Unit Structs struct Line; &lt;span class="fragment fade-in-then-semi-out"&gt;let line = Line;&lt;/span&gt;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Initializing structs with fields&lt;/h3&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;// Defining the struct struct Person { name: String, age: u32 }&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Instantiating a struct let alice = Person { name: String::from("Alice"), age: 48 };&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Shorthand field assignment let name = String::from("Bob"); let bob = Person { name, // Variable name and field name need to match age: 33 };&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Shorthand doesn't work with references fn create_homonymous_from_name(name: &amp;String) -&gt; Person { &lt;span class="fragment strike"&gt;Person { name, // Err, name is a reference age: 33 }&lt;/span&gt; }&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Shorthand struct update syntax let alice = Person { name: String::from("Alice"), age: 55 }; let bob = Person { name: String::from("Bob"), ..alice // Both instances must be of the same struct type // Shorthand must be at the end }; &lt;span class="fragment fade-in-then-semi-out"&gt;let bob = Person { name: String::from("Bob"), &lt;span class="fragment strike"&gt;..alice &lt;/span&gt; // Err, "alice" was consumed in the previous shorthad };&lt;/span&gt;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Shorthand doesn't work with references fn create_homonymous_from_person(person: &amp;Person) -&gt; Person { &lt;span class="fragment strike"&gt;Person { age: 33, ..person // Err, person is a reference }&lt;/span&gt; }&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Structs: ownership and mutability&lt;/h3&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;// Accessing fields let alice = Person { name: String::from("Alice"), age: 33 }; &lt;span class="fragment fade-in-then-semi-out"&gt;println!("Alice's name is {}", alice.name); // prints "Alice's name is Alice"&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;let age: u32 = alice.age; let age: u32 = alice.age; // Ok, u32 is unconsumable&lt;/span&gt; &lt;span class="fragment fade-in"&gt;let name: String = alice.name;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;&lt;span class="fragment strike"&gt;let name: String = alice.name;&lt;/span&gt; // Err, "alice" was partially consumed in the previous line&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;&lt;span class="fragment strike"&gt;println!("Alice's name is {}", alice.name);&lt;/span&gt; // Err, "alice" was partially consumed in the previous line&lt;/span&gt;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Consumable by default, unlike tuples and arrays struct Color(u32, u32, u32); let blue_a = Color(0, 0, 255); let blue_b = blue_a; &lt;span class="fragment strike"&gt;let blue_c = blue_a;&lt;/span&gt; // Err, "blue_a" was consumed in the previous line&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Mutability cascades let alice = Person { name: String::from("Alic"), age: 33 }; &lt;span class="fragment strike"&gt;alice.age = 34;&lt;/span&gt; // Err, "alice" is immutable&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Mutability cascades let mut alice = Person { name: String::from("Alic"), age: 33 }; alice.age = 34; // Ok &lt;span class="fragment fade-in"&gt;alice.age = 35; // Ok&lt;/span&gt; &lt;span class="fragment fade-in"&gt;alice.name = String::from("Alice"); // Ok&lt;/span&gt;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Mutability cascades let color = Color(0, 0, 255); &lt;span class="fragment strike"&gt;color.0 = 100;&lt;/span&gt; // Err, "color" is immutable&lt;/span&gt;&lt;/span&gt; &lt;span class="fragment fade-in"&gt;let mut color = Color(0, 0, 255); color.0 = 100; // Ok&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Implementation blocks: instance methods&lt;/h3&gt; &lt;div class="container"&gt; &lt;div class="column"&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;struct Person { name: String, age: u32 } &lt;span class="fragment fade-in-then-semi-out"&gt;impl Person { &lt;span class="fragment fade-in"&gt;// "self" must be the first parameter // Refers to the struct instance fn is_underage(&amp;self) -&gt; bool { self.age &lt; 18 }&lt;/span&gt; } &lt;span class="fragment fade-in"&gt;let alice = Person { name: String::from("Alice"), age: 33 }; // "alice" is "self" in this function call let is_alice_underage: bool = alice.is_underage();&lt;/span&gt;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;impl Person { // We need a mutable reference of a Person to call "change_name" fn change_name(&amp;mut self, new_name: String) -&gt; () { self.name = new_name; } } &lt;span class="fragment fade-in-then-semi-out"&gt;let alice = Person { name: String::from("Alice"), age: 33 }; &lt;span class="fragment strike"&gt;alice.change_name(String::from("Bob"));&lt;/span&gt; // Err, "alice" was not declared as mutable&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;let mut alice = Person { name: String::from("Alice"), age: 33 }; alice.change_name(String::from("Bob")); // Ok&lt;/span&gt;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;impl Person { // We need full ownership of a Person to call "older_person" fn older_person(self, other_person: Person) -&gt; Person { if self.age &gt;= other_person.age { self } else { other_person } } } &lt;span class="fragment fade-in-then-semi-out"&gt;let alice = Person { name: String::from("Alice"), age: 33 }; let bob = Person { name: String::from("Bob"), age: 34 }; let older_person = alice.older_person(bob); &lt;span class="fragment fade-in-then-semi-out"&gt;&lt;span class="fragment strike"&gt;let name = alice.name;&lt;/span&gt; // Err, "alice" was consumed when calling "older_person"&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;&lt;span class="fragment strike"&gt;let name = bob.name;&lt;/span&gt; // Err, "bob" was consumed when calling "older_person"&lt;/span&gt; &lt;/span&gt;&lt;/span&gt; &lt;!-- TODO: what to say about .into()? --&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Implementation blocks: static methods&lt;/h3&gt; &lt;li class="fragment fade-in-then-semi-out"&gt; There is no default constructor &lt;br&gt; &lt;ul&gt; &lt;li class="fragment fade-in-then-semi-out"&gt;Define your own with static functions&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;struct Person { name: String, age: u32 } impl Person { &lt;span class="fragment fade-in"&gt;// There is no "self" parameter // Does not require an existing person fn new(age: u32, name: String) -&gt; Self { // "Self" refers to Person, the type we are implementing a block for Person { name, age } }&lt;/span&gt; } &lt;span class="fragment fade-in"&gt; let alice = Person::new(33, String::from("Alice"));&lt;/span&gt; &lt;!-- TODO: what to say about from? --&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;The String Struct&lt;/h3&gt; &lt;li class="fragment fade-in-then-semi-out"&gt;Not the same as a string literal (&amp;str)&lt;/li&gt; &lt;li class="fragment fade-in-then-semi-out"&gt;String *is* a struct, so it behaves like one&lt;/li&gt; &lt;li class="fragment fade-in-then-semi-out"&gt;Dynamic allocation&lt;/li&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;let string_a = String::from("hello world!"); &lt;span class="fragment fade-in-then-semi-out"&gt;let string_b = string_a; &lt;span class="fragment strike"&gt;let string_c = string_a;&lt;/span&gt; // Err, "string_a" was consumed in the previous line&lt;/span&gt;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;let mut string_a = String::from("hello"); string_a.push_str(" world!"); // ".push_str(&amp;mut self)" needs a mutable reference to the String&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// format!() is similar to println!(), but creates a String instead of printing let string_a = String::from("world"); let string_b: String = format!("hello {}!", string_a); &lt;span class="fragment fade-in-then-semi-out"&gt;let string_c: String = format!("bye {}!", string_a); // Ok, format doesn't consume&lt;/span&gt;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Does not support indexing let s = String::from("hello world!"); &lt;span class="fragment strike"&gt;let first_char = s[0];&lt;/span&gt; // Err&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Enums&lt;/h3&gt; &lt;li class="fragment fade-in-then-semi-out"&gt;Type that holds only variant from a fixed set&lt;/li&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;// Defining an enum enum ShapeType { Rectangle, Square, Triangle } &lt;span class="fragment fade-in-then-semi-out"&gt;// Initializing an enum let shape_type = ShapeType::Rectangle; &lt;span class="fragment fade-in-then-semi-out"&gt;// Matching match shape_type { ShapeType::Rectangle =&gt; { println!("shape_type is a rectangle"); }, ShapeType::Triangle =&gt; { println!("shape_type is a triangle"); }, ShapeType::Square =&gt; { println!("shape_type is a square"); }, }&lt;/span&gt;&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;let shape_type = ShapeType::Rectangle; // Destructuring with "if let" if let ShapeType::Rectangle = shape_type { println!("shape_type is a rectangle"); }&lt;/span&gt; &lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Enums with payload (I)&lt;/h3&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;// Imagine we define these types enum ShapeType { Rectangle, Triangle, Square } &lt;span class="fragment fade-in-then-semi-out"&gt;struct Rectangle { shape_type: ShapeType, width: f32, height: f32, } struct Triangle { shape_type: ShapeType, base: f32, height: f32 } struct Square { shape_type: ShapeType, size: f32, } &lt;span class="fragment fade-in-then-semi-out"&gt;// This style of joining types gives problems when writing functions for all types fn area(shape: ?) -&gt; f32 { ... }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Enums with payload (II)&lt;/h3&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;// Instead, each enum variant can have its own payload enum Shape { Rectangle { width: f32, height: f32, }, Triangle { base: f32, height: f32 }, Square { size: f32 } } &lt;span class="fragment fade-in-then-semi-out"&gt;fn area(shape: Shape) -&gt; f32 { match shape { // Destructuring of the enum payload Shape::Rectangle { width, height } =&gt; width * height, Shape::Triangle { base, height } =&gt; width * height / 2, Shape::Square { size } =&gt; size * size, } }&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Enums with payload (III)&lt;/h3&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;// Every variant can have a different payload style enum GeometricObjects { Point, // Unit variant Line(u32, String), // Tuple-like variant Rectangle { // Struct-like variant width: f32, height: f32, }, }&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Matching (I)&lt;/h3&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;// Matching doesn't consume let shape = Shape::Rectangle; match shape { Shape::Rectangle =&gt; { println!("shape is a rectangle"); }, Shape::Triangle =&gt; { println!("shape is a triangle"); }, Shape::Square =&gt; { println!("shape is a square"); }, } match shape { // Ok Shape::Rectangle =&gt; { println!("shape is a rectangle"); }, Shape::Triangle =&gt; { println!("shape is a triangle"); }, Shape::Square =&gt; { println!("shape is a square"); }, }&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;let shape = Shape::Rectangle; // Can have a return value let is_rectangle = match shape { Shape::Rectangle =&gt; true, Shape::Triangle =&gt; false, Shape::Square =&gt; false, }; // Notice the ';'&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// But all match arms must return the same type let is_rectangle = match shape { Shape::Rectangle =&gt; true, &lt;span class="fragment strike"&gt;Shape::Triangle =&gt; String::from("No"), &lt;/span&gt; // Err, arms don't return the same type Shape::Square =&gt; false, };&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;let shape = Shape::Rectangle; // Variants can be ommitted let is_rectangle = match shape { Shape::Rectangle =&gt; true, _ =&gt; false, // '_' means "any other variant" }; &lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Matching (II)&lt;/h3&gt; &lt;li class="fragment fade-in-then-semi-out"&gt;One of the most powerful features of Rust&lt;/li&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;// Matching over a boolean let sample_boolean = true; match sample_boolean { true =&gt; println!("sample_boolean is true"), false =&gt; println!("sample_boolean is false"), }&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Matching over numbers let sample_integer = 5; match sample_integer { 0 =&gt; println!("sample_integer is 0"), 1..3 =&gt; println!("sample_integer is greater or equal than 1 and less than 3"), _ =&gt; println!("sample_integer is greater or equal than 3") }&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Matching over characters let sample_char = 'A'; match sample_char { 'a'..='z' =&gt; println!("sample_char is lowercase"), 'A'..='Z' =&gt; println!("sample_char is uppercase"), _ =&gt; println!("sample_char is not a letter") }&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Matching (III)&lt;/h3&gt; &lt;pre&gt;&lt;code class="rust" data-noescape&gt;&lt;span class="fragment fade-in-then-semi-out"&gt;// '|' as or operator let sample_integer_a = 5; match sample_integer_a { 0 | 1 | 2 =&gt; println!("sample_integer_a is less than 3"), _ =&gt; println!("sample_integer_a is greater or equal than 3") }&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// Using "if" to match let sample_integer_a = 1; let sample_integer_b = 5; match sample_integer_a { 0..=3 if sample_integer_b &lt; 3 =&gt; println!("both sample_integer_a and sample_integer_b are less than 3"), _ =&gt; println!("some number is greater or equal to 3") }&lt;/span&gt; &lt;span class="fragment fade-in-then-semi-out"&gt;// If we have these types enum Shape { Rectangle { width: f32, height: f32, }, Triangle { base: f32, height: f32 }, Square { size: f32 } } struct Image { image_src: String } enum SVGObject { Shape(Shape), Image(Image) } let svg_object = SVGObject::Shape(Shape::Square { size: 3.0 }); &lt;span class="fragment fade-in-then-semi-out"&gt;// We can match like this match svg_object { // Double destructuring SVGObject::Shape(Shape::Square { size }) =&gt; println!("svg_object is a square"), SVGObject::Image(Image { image_src }) =&gt; println!("svg_object is an image with image_src: {}", image_src), _ =&gt; {} }&lt;/span&gt;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="module"&gt; import Reveal from "reveal.js"; import Markdown from "reveal.js/plugin/markdown/markdown.esm.js"; import RevealHighlight from "reveal.js/plugin/highlight/highlight.esm.js"; import RevealNotes from "reveal.js/plugin/notes/notes.esm.js"; import RevealNestedFragments from "reveal.js-nested-fragments"; let deck = new Reveal({ transition: "none", plugins: [ Markdown, RevealHighlight, RevealNotes, RevealNestedFragments, ], }); deck.initialize(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</title></head><body></body></html>